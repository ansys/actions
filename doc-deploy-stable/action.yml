name: "Documentation deploy stable version."
description: "Deploy stable documentation artifacts to desired repository branch."

inputs:
  doc_artifact_name:
    description: "Name of the HTML documentation artifact."
    required: false
    default: 'documentation-html'
    type: string
  decompress_artifact:
    description: "If ``True``, the documentation artifact name is decompressed. If ``False``, content is assumed to be a collection of HTML files."
    required: false
    default: false
    type: string
  repository:
    description: "Name of the repository in the form of ``username/repository`` used to deploy the documentation. If not specified, current repository is used."
    required: false
    default: 'current'
    type: string
  branch:
    description: "Desired deployment branch name. If not specified, ``gh-pages`` is used."
    required: false
    default: 'gh-pages'
    type: string
  cname:
    description: 'The canonical name of the documentation website.'
    required: true
    type: string
  token:
    description: "Required token for documentation deployment."
    required: true
    type: string
  commit_message:
    description: "Commit message used when deploying the documentation"
    required: false
    default: 'DOC: update development documentation'
    type: string
  render_last:
    description: 'Number of last versions to be rendered in multi-doc.'
    default: '3'
    required: false
    type: string

runs:
  using: "composite"
  steps:

    # Verify that a tag event triggered the workflow. This is a strong requirement to
    # guarantee that any stable documentation deployment is linked to a tag.
    # If a tag is detected, verify that it is compliant with semantic version syntax.

    # Tags starting with a 'v*' followed by a semantic version of the following 
    # the syntax <MAJOR.MINOR.PATCH> are valid.

    - name: "Check documentation deployment was triggered by a tag"
      shell: bash
      if: github.ref_type != 'tag'
      run: |
        echo "[PYANSYS ACTIONS ERROR]"
        echo "Stable documentation deployment can only be triggered by a tag."
        echo "Consider adding the following conditional when using the pyansys/actions/doc-deploy-stable:"
        echo ""
        echo "if: github.event_name == 'push' && contains(github.ref, 'refs/tags')"
        echo ""
        exit 1

    - name: "Check tag is compliant with semantic versioning: (v)<MAJOR.MINOR.PATCH>"
      shell: bash
      run: |
        tag = ${{ github.ref_name }}
        version = ${tag##*v}

        if [[ $version =~ ^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)$ ]]; then
          echo "VERSION_MAJOR=$(echo $version | cut -d . -f1)" >> $GITHUB_ENV
          echo "VERSION_MINOR=$(echo $version | cut -d . -f2)" >> $GITHUB_ENV
          echo "VERSION=${{ env.VERSION_MAJOR }}${{ env.VERSION_MINOR }}" >> $GITHUB_ENV
        else
          echo "[PYANSYS ACTIONS ERROR]"
          echo "Version $version is not a valid stable semantic version."
          echo "Only <MAJOR.MINOR.PATCH> formats are supported."
          exit 1
        fi

    # Checkout the repository branch for deploying the documentation. If this
    # step fails, then it means that the provided token is not valid.

    - name: "Get the name of the repository"
      shell: bash
      run: |
        if [[ "${{ inputs.repository }}" == "current" ]]; then
          echo "REPOSITORY=${{ github.repository }}" >> GITHUB_ENV
        else;
          echo "REPOSITORY=${{ inputs.repository }}" >> GITHUB_ENV
        fi

    - name: "Checkout ${{ env.REPOSITORY }} repository"
      uses: actions/checkout@v3
      with:
        repository: ${{ env.REPOSITORY }}
        ref: ${{ inputs.branch }}
        token: ${{ inputs.token }}

    # Download the stable documentation artifact in a folder that has the same
    # name as the version number. Decompress artifact if required. Finally,
    # display the structure of the directory to verify that it has the right
    # layout.

    - name: "Clean destination folder"
      shell: bash
      run:
        rm -rf version/${{ env.VERSION }} && mkdir -p version/${{ env.VERSION }}

    - name: "Download the stable documentation artifact"
      uses: actions/download-artifact@v3
      with:
        name: ${{ inputs.doc-artifact-name }}
        path: version/${{ env.VERSION }}

    - name: "Decompress artifact content"
      shell: bash
      if: inputs.decompress_artifact == 'true'
      run: |
        sudo apt-get install cargo && cargo install ouch && ouch --version
        cd version/${{ env.VERSION }} && compressed_artifact=$(ls .)
        ouch decompress $compressed_artifact && rm $compressed_artifact

    - name: "Display structure of version/dev"
      shell: bash
      run: |
        ls -R version/${{ env.VERSION }}

    # Generate the URL for deploying the documentation. Check if this URL
    # exists in the versions file. If not, it gets added and the whole 
    
    - name: "Generate URL for the desired version"
      shell: bash
      run: |
        echo "URL_VERSION=https://${{ inputs.cname }}/version/${{ env.VERSION }}/" >> $GITHUB_ENV

    - name: "Check if URL exists in the ${{ inputs.versions_file }} file" 
      shell: bash
      run: |
        if grep -q -E "" versions.json;



    - name: "Install jq for manipulating ${{ inputs.versions_file }} file"
      shell: bash
      run: |
        sudo apt-get install jq

    # Verify if 
    - name: "Install jq for manipulating ${{ inputs.versions_file }} file"
      shell: bash
      run: |
        sudo apt-get install jq




    - name: "Update the version JSON file"
      shell: bash
      run: | 
        python version_updater.py \
          --cname ${{ inputs.cname }} \
          --json_filename ${{ inputs.versions_file }} \
          --new_version ${{ env.VERSION }} \
          --render_last ${{ inputs.render_last }}
        # Remove the script to avoid Git tracking it
        rm -rf version_mapper.py






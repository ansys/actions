name: "Documentation deploy stable version."
description: "Deploy stable documentation artifacts to desired repository branch."

inputs:
  doc-artifact-name:
    description: "Name of the HTML documentation artifact."
    required: false
    default: 'documentation-html'
    type: string
  decompress-artifact:
    description: "If ``True``, the documentation artifact name is decompressed. If ``False``, content is assumed to be a collection of HTML files."
    required: false
    default: false
    type: string
  repository:
    description: "Name of the repository in the form of ``username/repository`` used to deploy the documentation. If not specified, current repository is used."
    required: false
    default: 'current'
    type: string
  branch:
    description: "Desired deployment branch name. If not specified, ``gh-pages`` is used."
    required: false
    default: 'gh-pages'
    type: string
  cname:
    description: 'The canonical name of the documentation website.'
    required: true
    type: string
  token:
    description: "Required token for documentation deployment."
    required: true
    type: string
  commit-message:
    description: "Commit message used when deploying the documentation"
    required: false
    default: 'DOC: update development documentation'
    type: string
  render-last:
    description: 'Number of last versions to be rendered in multi-doc.'
    default: '3'
    required: false
    type: string

runs:
  using: "composite"
  steps:

    # Verify that a tag event triggered the workflow. This is a strong requirement to
    # guarantee that any stable documentation deployment is linked to a tag.
    # If a tag is detected, verify that it is compliant with semantic version syntax.

    # Tags starting with a 'v*' followed by a semantic version of the following 
    # the syntax <MAJOR.MINOR.PATCH> are valid.

    - name: "Check documentation deployment was triggered by a tag"
      shell: bash
      if: github.ref_type != 'tag'
      run: |
        echo "[PYANSYS ACTIONS ERROR]"
        echo "Stable documentation deployment can only be triggered by a tag."
        echo "Consider adding the following conditional when using the pyansys/actions/doc-deploy-stable:"
        echo ""
        echo "if: github.event_name == 'push' && contains(github.ref, 'refs/tags')"
        echo ""
        exit 1

    - name: "Check tag ${{ github.ref_name }} matches: (v)<MAJOR.MINOR.PATCH>"
      shell: bash
      run: |
        tag=${{ github.ref_name }}
        version=${tag##*v}

        if [[ $version =~ ^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)$ ]]; then
          echo "VERSION_MAJOR=$(echo $version | cut -d . -f1)" >> $GITHUB_ENV
          echo "VERSION_MINOR=$(echo $version | cut -d . -f2)" >> $GITHUB_ENV
        else
          echo "[PYANSYS ACTIONS ERROR]"
          echo "Version $version is not a valid stable semantic version."
          echo "Only (v)<MAJOR.MINOR.PATCH> formats are supported."
          exit 1
        fi

    - name: "Assemble the version number using the major and minor numbers"
      shell: bash
      run: |
          echo "VERSION=${{ env.VERSION_MAJOR }}.${{ env.VERSION_MINOR }}" >> $GITHUB_ENV

    # Checkout the repository branch for deploying the documentation. If this
    # step fails, then it means that the provided token is not valid.

    - name: "Get the name of the repository"
      shell: bash
      run: |
        if [[ "${{ inputs.repository }}" == "current" ]]; then
          echo "REPOSITORY=${{ github.repository }}" >> $GITHUB_ENV
        else
          echo "REPOSITORY=${{ inputs.repository }}" >> $GITHUB_ENV
        fi

    - name: "Checkout ${{ env.REPOSITORY }} repository"
      uses: actions/checkout@v3
      with:
        repository: ${{ env.REPOSITORY }}
        ref: ${{ inputs.branch }}
        token: ${{ inputs.token }}

    # Download the stable documentation artifact in a folder that has the same
    # name as the version number. Decompress artifact if required. Finally,
    # display the structure of the directory to verify that it has the right
    # layout.

    - name: "Clean version content"
      shell: bash
      run: |
        if [ -d version/${{ env.VERSION }} ]; then
          echo "VERSION_EXISTS=true" >> $GITHUB_ENV
        else
          echo "VERSION_EXISTS=false" >> $GITHUB_ENV
        fi
        rm -rf version/${{ env.VERSION }} && mkdir -p version/${{ env.VERSION }}

    - name: "Download the stable documentation artifact"
      uses: actions/download-artifact@v3
      with:
        name: ${{ inputs.doc-artifact-name }}
        path: version/${{ env.VERSION }}

    - name: "Decompress artifact content"
      shell: bash
      if: inputs.decompress-artifact == 'true'
      run: |
        sudo apt-get install cargo && cargo install ouch && ouch --version
        cd version/${{ env.VERSION }} && compressed_artifact=$(ls .)
        ouch decompress $compressed_artifact && rm $compressed_artifact

    - name: "Display structure of version/dev"
      shell: bash
      run: |
        ls -R version/${{ env.VERSION }}

    # Collect all stable releases (X.Y). Crop until matching the desired number
    # to be displayed in the switcher. Generate the 'versions.json' file including
    # development and latest stable links.

    - name: "Install 'sponge' and 'jq' for manipulating JSON files"
      shell: bash
      run: |
        sudo apt-get install moreutils jq

    - name: "Create a clean 'versions.json' file"
      shell: bash
      run: |
        rm -rf versions.json && touch versions.json && echo '[]' > versions.json

    - name: "Add the development version to the 'versions.json' file"
      shell: bash
      run: |
        url_dev="https://${{ inputs.cname }}/version/dev/"
        jq --arg url $url_dev '. += [{"name": "dev", "version": "dev", "url": $url}]' versions.json | sponge versions.json
        cat versions.json

    - name: "Populate the 'verisons.json' file with the desired amount of versions"
      shell: bash
      run: |
        for version in $( ls version | \
                          grep -E "^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)$" | \
                          sort -r --version-sort | \
                          head -${{ inputs.render-last }}); do
          url="https://${{ inputs.cname }}/version/$version/"
          jq --arg version $version --arg url $url '. += [{"name": $version, "version": $version, "url": $url}]' < versions.json | sponge versions.json
        done

        cat versions.json

    - name: "Convert the first stable version into the 'stable' one"
      shell: bash
      run: |
        jq '.[1].name += " (stable)"' versions.json | sponge versions.json
        jq '.[1].url |= (sub("version/.*$";"version\/stable/")) ' versions.json | sponge versions.json
        cat versions.json

    - name: "Find the latest stable version"
      shell: bash
      run: |
        stable_version=$(jq '.[1].version' versions.json | grep -o '".*"' | sed 's/"//g')
        echo "LATEST_STABLE_VERSION=$stable_version" >> $GITHUB_ENV

    - name: "Update the content for the 'version/stable' folder"
      shell: bash
      run: |
        rm -rf version/stable && cp -r version/${{ env.LATEST_STABLE_VERSION }} version/stable

    # Generate the content for the announcement file. Place a copy of this file
    # in each one of outdated stable versions. 

    - name: "Generate the template content for the 'announcement.html' file"
      shell: bash
      run: |
        cat > announcement.html <<'EOF'  
          <p>
            You are not viewing the most recent version of this documentation.
            The latest stable release is <a href="STABLE_URL">LATEST_STABLE_VERSION</a>
          </p>
        EOF

    - name: "Render the 'announcement.html' template with the desired stable version"
      shell: bash
      run: |
        latest_stable_version=${{ env.LATEST_STABLE_VERSION}}
        stable_url="https://${{ inputs.cname }}/version/stable/"
        sed -i "s|LATEST_STABLE_VERSION|$latest_stable_version|g" announcement.html
        sed -i "s|STABLE_URL|$stable_url|g" announcement.html

    - name: "Place the 'announcement.html' file in every public folder of all the outdated versions"
      shell: bash
      run: |
        for version_dir in $( ls version | \
                          grep -E "^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)$" | \
                          grep -v "${{ env.LATEST_STABLE_VERSION }}" | \
                          sort -r --version-sort ); do
            find version/$version_dir -type d -not \( -path "*/_*" -type d -prune \) -exec cp announcement.html {} \;
        done

    - name: "Delete the 'announcement.html' file used as template"
      shell: bash
      run: |
        rm -rf announcement.html

    # Generate the redirection link. Since this is the stable documentation
    # deployment action, there is always a 'version/stable' folder. Hence,
    # redirection link always points to this folder.

    - name: "Generate the redirection URL"
      shell: bash
      run: |
        echo "REDIRECTION_URL=https://${{ inputs.cname }}/version/stable/" >> $GITHUB_ENV

    - name: "Create the 'index.html' redirection file"
      shell: bash
      run: |
        echo "<!DOCTYPE html>" > index.html
        echo "<meta charset=\"utf-8\">" >> index.html
        echo "<title>Redirecting to ${{ env.REDIRECTION_URL }}</title>" >> index.html
        echo "<meta http-equiv=\"refresh\" content=\"0; URL=${{ env.REDIRECTION_URL }}\">" >> index.html
        echo "<link rel=\"canonical\" href=\"${{ env.REDIRECTION_URL }}\">" >> index.html

    - name: "Show the contents of the 'index.html' redirection file"
      shell: bash
      run: |
          cat index.html

    # Create the '.nojekyll' and 'CNAME' file with the desired values

    - name: "Create '.nojekyll' and 'CNAME' files"
      shell: bash
      run: |
          touch .nojekyll CNAME
          echo "${{ inputs.cname }}" > CNAME

    # For deploying the documentation, a GitHub token or a deployment token is
    # required. The GitHub token is used when deploying to the current
    # repository while the deployment token is used to deploy to an external
    # repository.

    - name: "Deploy to ${{ inputs.branch }} branch of ${{ github.repository }} repository"
      if: inputs.repository == 'current'
      uses: peaceiris/actions-gh-pages@v3
      with:
        publish_dir: .
        publish_branch: ${{ inputs.branch }}
        github_token: ${{ inputs.token }}
        commit_message: ${{ inputs.commit-message }}
        keep_files: true
        force_orphan: true

    - name: "Deploy to ${{ inputs.branch }} branch of ${{ inputs.repository }}"
      if: inputs.repository != 'current'
      uses: peaceiris/actions-gh-pages@v3
      with:
        publish_dir: .
        publish_branch: ${{ inputs.branch }}
        personal_token: ${{ inputs.token }}
        external_repository: ${{ inputs.repository }}
        commit_message: ${{ inputs.commit-message }}
        keep_files: true
        force_orphan: true

name: "Documentation deploy development version."
description: "Deploy development documentation artifacts to desired repository branch."

inputs:
  doc-artifact-name:
    description: "Name of the HTML documentation artifact."
    required: false
    default: 'documentation-html'
    type: string
  decompress-artifact:
    description: "If ``True``, the documentation artifact name is decompressed. If ``False``, content is assumed to be a collection of HTML files."
    required: false
    default: false
    type: string
  repository:
    description: "Name of the repository in the form of ``username/repository`` used to deploy the documentation. If not specified, current repository is used."
    required: false
    default: 'current'
    type: string
  branch:
    description: "Desired deployment branch name. If not specified, ``gh-pages`` is used."
    required: false
    default: 'gh-pages'
    type: string
  cname:
    description: 'The canonical name of the documentation website.'
    required: true
    type: string
  token:
    description: "Required token for documentation deployment."
    required: true
    type: string
  commit-message:
    description: "Commit message used when deploying the documentation"
    required: false
    default: 'DOC: update development documentation'
    type: string



runs:
  using: "composite"
  steps:

    # Checkout the repository branch for deploying the documentation. If this
    # step fails, then it means that the provided token is not valid.

    - name: "Get the name of the repository"
      shell: bash
      run: |
        if [[ "${{ inputs.repository }}" == "current" ]]; then
          echo "REPOSITORY=${{ github.repository }}" >> $GITHUB_ENV
        else
          echo "REPOSITORY=${{ inputs.repository }}" >> $GITHUB_ENV
        fi

    - name: "Checkout ${{ env.REPOSITORY }} repository"
      uses: actions/checkout@v3
      with:
        repository: ${{ env.REPOSITORY }}
        ref: ${{ inputs.branch }}
        token: ${{ inputs.token }}

    # Download the documentation artifact from the current workflow. If the
    # artifact contains a compressed file, decompress it. Display the structure
    # of the 'version/dev' directory at the end of the process to verify the
    # layout of the folder is the right one.

    - name: "Clean destination folder"
      shell: bash
      run:
        rm -rf version/dev && mkdir -p version/dev

    - name: "Download the development documentation artifact"
      uses: actions/download-artifact@v3
      with:
        name: ${{ inputs.doc-artifact-name }}
        path: version/dev

    - name: "Decompress artifact content"
      shell: bash
      if: inputs.decompress-artifact == 'true'
      run: |
        sudo apt-get install cargo && cargo install ouch && ouch --version
        cd version/dev && compressed_artifact=$(ls .)
        ouch decompress $compressed_artifact && rm $compressed_artifact

    - name: "Display structure of version/dev"
      shell: bash
      run: |
        ls -R version/dev

    # Create the 'versions.json' file if it does not exist. Note that this step
    # is not required in the 'doc-deploy-stable' action. The reason is that
    # stable releases are born after a development version exists. This forces
    # users to use this action before using the stable deploy one.

    - name: "Create the 'versions.json' file if not present"
      shell: bash
      run: |
        if ! [[ -f "versions.json" ]];
        then
            sudo apt-get install moreutils jq
            echo '[]' > versions.json
            url_dev="https://${{ inputs.cname }}/version/dev/"
            jq --arg url $url_dev '. += [{"name": "dev", "version": "dev", "url": $url}]' versions.json | sponge versions.json
        fi
        cat versions.json

    # Generate an 'index.html' for redirection to the latest stable version of
    # the documentation. If no stable version has been release, a redirection
    # to the development documentation is generated.

    - name: "Generate the redirection URL"
      shell: bash
      run: |
        if $(grep -q "(stable)" versions.json)
        then 
          echo "Redirecting to the latest stable version..."
          echo "REDIRECTION_URL=https://${{ inputs.cname }}/version/stable/" >> $GITHUB_ENV
        else 
          echo "Redirecting to the latest development version..."
          echo "REDIRECTION_URL=https://${{ inputs.cname }}/version/dev/" >> $GITHUB_ENV
        fi

    - name: "Create the 'index.html' redirection file"
      shell: bash
      run: |
        echo "<!DOCTYPE html>" > index.html
        echo "<meta charset=\"utf-8\">" >> index.html
        echo "<title>Redirecting to ${{ env.REDIRECTION_URL }}</title>" >> index.html
        echo "<meta http-equiv=\"refresh\" content=\"0; URL=${{ env.REDIRECTION_URL }}\">" >> index.html
        echo "<link rel=\"canonical\" href=\"${{ env.REDIRECTION_URL }}\">" >> index.html

    - name: "Show the contents of the 'index.html' redirection file"
      shell: bash
      run: |
          cat index.html

    # Create the '.nojekyll' and 'CNAME' file with the desired values

    - name: "Create '.nojekyll' and 'CNAME' files"
      shell: bash
      run: |
          touch .nojekyll CNAME
          echo "${{ inputs.cname }}" > CNAME
      
    # For deploying the documentation, a GitHub token or a deployment token is
    # required. The GitHub token is used when deploying to the current
    # repository while the deployment token is used to deploy to an external
    # repository.

    - name: "Deploy to ${{ inputs.branch }} branch of ${{ github.repository }} repository"
      if: inputs.repository == 'current'
      uses: peaceiris/actions-gh-pages@v3
      with:
        publish_dir: .
        publish_branch: ${{ inputs.branch }}
        github_token: ${{ inputs.token }}
        commit_message: ${{ inputs.commit-message }}
        keep_files: true
        force_orphan: true

    - name: "Deploy to ${{ inputs.branch }} branch of ${{ inputs.repository }}"
      if: inputs.repository != 'current'
      uses: peaceiris/actions-gh-pages@v3
      with:
        publish_dir: .
        publish_branch: ${{ inputs.branch }}
        personal_token: ${{ inputs.token }}
        external_repository: ${{ inputs.repository }}
        commit_message: ${{ inputs.commit-message }}
        keep_files: true
        force_orphan: true

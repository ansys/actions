# Copyright (C) 2022 - 2025 ANSYS, Inc. and/or its affiliates.
# SPDX-License-Identifier: MIT
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

name: |
  Check licenses action

description: |
  Verifies if the licenses of the dependencies installed in the current
  environment are compliant with PyAnsys guidelines. This action is assumed to
  be used in its own job step. It clones the project and installs the project with
  its runtime dependencies.

  .. note::

    **This action relies on PyPI metadata to identify the license for each package.**

    If the metadata are flawed or not included, it may lead to
    inconclusive results. In those cases, please perform a thorough review of the
    package you are using. Additionally, it is advised not to blindly rely on PyPI metadata.
    Even though packages may define their license as of a certain type, the
    package could be not applying properly its licensing conditions.

  .. jinja:: check-licenses

      .. grid:: 1 1 1 2
          :gutter: 2

          .. grid-item-card:: :octicon:`codescan-checkmark` Accepted third party licenses

              {% for license in accepted_licenses %}
              * {{ license }}
              {% endfor %}

          .. grid-item-card:: :octicon:`package` Ignored packages

              {% for package in ignored_packages %}
              * {{ package }}
              {% endfor %}

  .. admonition:: Projects requiring additional licenses or packages

    If a certain project requires a license or package that is not supported,
    `open an issue <https://github.com/ansys/actions/issues>`_ in the
    `official ansys/actions repository
    <https://github.com/ansys/actions>`_. For additional support, please
    contact the `PyAnsys support <mailto:support@pyansys.com>`_.

inputs:

  # Optional inputs

  python-version:
    description: |
      Python version used for installing and executing licence check.
    default: '3.11'
    required: false
    type: string

  use-python-cache:
    description: |
      Whether to use the Python cache for installing previously downloaded
      libraries. If ``true``, previously downloaded libraries are installed from the
      Python cache. If ``false``, libraries are downloaded from the PyPI index.
    required: false
    default: true
    type: boolean

  target:
    description: |
      Optional target used during the building process.
    required: false
    default: ''
    type: string

  whitelist-license-check:
    description: |
      Optional list of packages to ignore during the license check. Separated by a comma.
    required: false
    default: ''
    type: string

  skip-install:
    description: |
      Whether to skip the installation of the project. The default is ``false``.
      If used in combination with other actions, it might not be needed to install
      the project.
    default: false
    required: false
    type: boolean

  checkout:
    description: |
      Whether to clone the repository in the CI/CD machine. Default value is
      ``true``.
    default: true
    required: false
    type: boolean

  use-uv:
    description: |
      Whether to use uv as the default package manager instead of pip. Default value is ``true``.
    default: true
    required: false
    type: boolean

  activate-venv:
    description: |
      When this action is used in combination with other actions, it might need to
      activate the virtual environment created by those actions. If ``skip-install`` input
      is set to ``true``, this input is required to activate the virtual environment. If
      ``skip-install`` is ``false``, this input is not needed and is ignored.
    required: false
    default: ''
    type: string

runs:
  using: "composite"
  steps:

    - name: Check virutal environment existence (if needed)
      if: ${{ inputs.skip-install == 'true' && inputs.activate-venv == '' }}
      uses: ansys/actions/_logging@main
      with:
        level: "ERROR"
        message: >
          When skip-install is set to true, activate-venv input must be provided
          to activate the virtual environment created by previous actions. Otherwise,
          the action cannot proceed.

    - name: Warn about input combination
      if: ${{ inputs.skip-install == 'false' && inputs.activate-venv != '' }}
      uses: ansys/actions/_logging@main
      with:
        level: "WARNING"
        message: >
          When skip-install is set to false, activate-venv input is not needed
          and will be ignored.

    - name: Check python version
      id: check-python-version
      shell: bash
      env:
        PYTHON_VERSION: ${{ inputs.python-version }}
      run: |
        MIN_VERSION="3.10"
        if [ "$(printf '%s\n' "$PYTHON_VERSION" "$MIN_VERSION" | sort -V | head -n1)" != "$MIN_VERSION" ]; then
          echo "PYTHON_TOO_OLD=true" >> "${GITHUB_OUTPUT}"
        fi

    - name: Break if Python version is too old
      uses: ansys/actions/_logging@v10.1.5
      if: steps.check-python-version.outputs.PYTHON_TOO_OLD == 'true'
      with:
        level: "ERROR"
        message: >
          The check-licenses action leverages Ansys fork of pip-licenses.
          This package requires Python 3.10 or higher.

    - name: "Install Git and clone project"
      uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      with:
        persist-credentials: false
      if: ${{ inputs.checkout == 'true' }}

    - name: "Set up Python"
      if: inputs.skip-install == 'false'
      uses: ansys/actions/_setup-python@v10.1.5
      with:
        python-version: ${{ inputs.python-version }}
        use-cache: ${{ inputs.use-python-cache }}
        provision-uv: ${{ inputs.use-uv }}
        prune-uv-cache: ${{ inputs.use-python-cache != 'true' }}

    - name: "Identify the build system"
      if: inputs.skip-install == 'false'
      id: build-system
      shell: bash
      run: |
        if [[ -f "pyproject.toml" ]] && grep -q 'build-backend = "poetry\.core\.masonry\.api"' "pyproject.toml"; then
          echo "BUILD_BACKEND=$(echo 'poetry')" >> ${GITHUB_OUTPUT}
        else
          echo "BUILD_BACKEND=$(echo 'pip')" >> ${GITHUB_OUTPUT}
        fi

    # NOTE: Installation of poetry in a separate environment to the project to
    # avoid situations in which both poetry and the project have shared
    # dependencies with different version. This can lead to CICD failures. For
    # more information, see https://github.com/ansys/actions/pull/560
    - name: "Add pipx/bin directory to Github Path"
      if: steps.build-system.outputs.BUILD_BACKEND == 'poetry' && inputs.skip-install == 'false'
      shell: bash
      run: echo "${RUNNER_TEMP}/pipx/bin" >> $GITHUB_PATH # zizmor: ignore[github-env] no workaround for this

    # NOTE: Poetry uses virtual environments when installing a project. As we
    # want to control that creation, we store POETRY_VIRTUALENVS_CREATE=false
    # in the GitHub environment.
    - name: "Set poetry environment variable(s)"
      if: steps.build-system.outputs.BUILD_BACKEND == 'poetry' && inputs.skip-install == 'false'
      shell: bash
      run: echo "POETRY_VIRTUALENVS_CREATE=false" >> $GITHUB_ENV

    # NOTE: Install pipx in a location that can be used in following CICD jobs
    # but ensure that poetry is installed in a temporary folder cleaned before
    # and after each job. This way poetry is kinda "installed at system level"
    # making it available in the following call and installed in a different
    # environment from the project.
    - name: "Install poetry and create a virtual environment"
      if: steps.build-system.outputs.BUILD_BACKEND == 'poetry' && inputs.skip-install == 'false'
      shell: bash
      run: |
        python -m pip install pipx
        python -m pipx install poetry
        python -m pipx inject poetry poetry-plugin-export
      env:
        PIPX_BIN_DIR: ${{ runner.temp }}/pipx/bin
        PIPX_HOME : ${{ runner.temp }}/pipx/home

    - name: "Create a virtual environment"
      if: inputs.skip-install == 'false'
      shell: bash
      env:
        USE_UV: ${{ inputs.use-uv }}
      run: |
        if [[ "$USE_UV" == 'true' ]]; then
          uv venv .venv
        else
          python -m venv .venv
        fi

    - name: "Set up virtual environment activation command"
      id: virtual-environment-activation-command
      shell: bash
      env:
        ACTIVATE_VENV: ${{ inputs.activate-venv }}
      run: |
        if [[ -n ${ACTIVATE_VENV} ]]; then
          echo "ACTIVATE_VENV=${ACTIVATE_VENV}" >> $GITHUB_OUTPUT
        else
          if [[ ${RUNNER_OS} == 'Windows' ]]; then
            echo "ACTIVATE_VENV=$(echo 'source .venv/scripts/activate')" >> $GITHUB_OUTPUT
          else
            echo "ACTIVATE_VENV=$(echo 'source .venv/bin/activate')" >> $GITHUB_OUTPUT
          fi
        fi

    - name: "Update pip"
      shell: bash
      env:
        ACTIVATE_VENV: ${{ steps.virtual-environment-activation-command.outputs.ACTIVATE_VENV }}
        INSTALL_COMMAND: ${{ inputs.use-uv == 'true' && 'uv pip install --no-managed-python' || 'python -m pip install' }}
      run: |
        ${ACTIVATE_VENV}
        $INSTALL_COMMAND -U pip

    - name: Clone ansys/pip-licenses on main branch
      uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      with:
        repository: ansys/pip-licenses
        path: "external/pip-licenses"
        ref: "main"
        persist-credentials: false

    - name: Install ansys/pip-licenses main branch
      shell: bash
      env:
        ACTIVATE_VENV: ${{ steps.virtual-environment-activation-command.outputs.ACTIVATE_VENV }}
        INSTALL_COMMAND: ${{ inputs.use-uv == 'true' && 'uv pip install --no-managed-python --no-cache' || 'python -m pip install --no-cache-dir' }}
      run: |
        ${ACTIVATE_VENV}
        $INSTALL_COMMAND external/pip-licenses

    - name: "Check if specific target is requested"
      id: specific-target-requested
      shell: bash
      env:
        TARGET: ${{ inputs.target }}
      run: |
        echo "install_target=$( [[ "${TARGET}" == '' ]] && echo '.' || echo ".[${TARGET}]")" >> ${GITHUB_OUTPUT}

    - name: "Install Python library"
      if: inputs.skip-install == 'false'
      shell: bash
      env:
        ACTIVATE_VENV: ${{ steps.virtual-environment-activation-command.outputs.ACTIVATE_VENV }}
        INSTALL_TARGET: ${{ steps.specific-target-requested.outputs.install_target }}
        INSTALL_COMMAND: ${{ inputs.use-uv == 'true' && 'uv pip install --no-managed-python' || 'python -m pip install' }}
      run:
        ${ACTIVATE_VENV}
        ${INSTALL_COMMAND} "$INSTALL_TARGET"

    - name:  "Install wget on Windows"
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        # Check if wget is installed - if not, install it
        if (-not (Get-Command wget -ErrorAction SilentlyContinue)) {
            Write-Host "wget is not installed. Installing using Chocolatey..."
            # Install wget using Chocolatey
            choco install wget -y
        } else {
            Write-Host "wget is already installed."
        }

    - name:  "Update bash on macOS"
      if: runner.os == 'macOS'
      shell: bash
      run: |
        brew install bash

    - name: "Download the list of accepted and ignored packages"
      shell: bash
      run: |
        wget https://raw.githubusercontent.com/ansys/actions/main/check-licenses/accepted-licenses.txt
        wget https://raw.githubusercontent.com/ansys/actions/main/check-licenses/ignored-packages.txt

    - name: "Process whitelisted packages provided on input"
      shell: bash
      env:
        WHITELIST_LICENSE_CHECK: ${{ inputs.whitelist-license-check }}
      run: |
        if [[ -n "${WHITELIST_LICENSE_CHECK}" ]]; then
          echo "Whitelisted packages: ${WHITELIST_LICENSE_CHECK}"
          # Split the input string by comma, trim values and append them to the ignored-packages.txt file
          IFS=',' read -ra whitelist <<< "${WHITELIST_LICENSE_CHECK}"
          for package in "${whitelist[@]}"; do
            echo "Ignoring whitelisted package: $package"
            echo "$package" >> ignored-packages.txt
          done
        fi

    - name: "Logging licenses and packages"
      id: log-licenses-and-packages
      shell: bash
      run: |
        # Load accepted licenses
        mapfile licenses_from_txt < accepted-licenses.txt
        accepted_licenses='Accepted licenses:\n'
        for license in ${licenses_from_txt[*]}; do accepted_licenses+="$license\n"; done
        echo "LOG_ACCEPTED_LICENSES=$accepted_licenses" >> ${GITHUB_OUTPUT}

        # Load accepted packages
        mapfile ignored_packages_from_txt < ignored-packages.txt
        ignored_packages='Ignored packages:\n'
        for pckg in ${ignored_packages_from_txt[*]}; do ignored_packages+="$pckg\n"; done
        echo "LOG_IGNORED_PACKAGES=$ignored_packages" >> ${GITHUB_OUTPUT}

    - name: Log ignored packages and accepted licenses
      uses: ansys/actions/_logging@v10.1.5
      with:
        level: "INFO"
        message: |
          Licenses accepted and packages ignored
          ----------------------------------------------

          ${{ steps.log-licenses-and-packages.outputs.LOG_ACCEPTED_LICENSES }}

          ${{ steps.log-licenses-and-packages.outputs.LOG_IGNORED_PACKAGES }}

    - name: "Check licences of packages"
      shell: bash
      env:
        ACTIVATE_VENV: ${{ steps.virtual-environment-activation-command.outputs.ACTIVATE_VENV }}
      run: |
        ${ACTIVATE_VENV}

        # Load accepted licenses
        mapfile licenses_from_txt < accepted-licenses.txt
        accepted_licenses=''
        for license in ${licenses_from_txt[*]}; do accepted_licenses+="$license\|"; done
        accepted_licenses=${accepted_licenses::-2}

        # Load accepted packages
        mapfile ignored_packages_from_txt < ignored-packages.txt
        ignored_packages=''
        for pckg in ${ignored_packages_from_txt[*]}; do ignored_packages+="$pckg "; done
        ignored_packages_from_txt=${ignored_packages_from_txt::-1}

        # Verify if the Python environment contains invalid licenses
        if [[ -z $(pip-licenses --ignore-packages $ignored_packages | awk 'NR>1 && NF >= 3 && $2 ~ /^[0-9]+(\.[0-9]+)*$/' | grep -v $accepted_licenses) ]]; then
          echo "All licenses are valid."
        else
          echo -e "\nInvalid licenses found:\n"
          pip-licenses --ignore-packages $ignored_packages | awk 'NR>1 && NF >= 3 && $2 ~ /^[0-9]+(\.[0-9]+)*$/' | grep -v $accepted_licenses | awk '{ for (i=3; i<=NF; i++) license = license $i (i==NF ? "" : " "); print $1 " " $2 " has " license; license="" }'
          # print all packages
          echo -e "\n\n"
          pip-licenses --ignore-packages $ignored_packages
          exit 1
        fi
